# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

"""
The standard interface that contains the error message when something goes wrong
"""
interface APIError {
  """The error message giving details about what went wrong"""
  message: String!
}

"""The role of a person in the complete production of a book"""
enum ArchitectRole {
  AUTHOR
  ILLUSTRATOR
}

"""The people who have worked on a book"""
type ArchitectsOnBooks {
  author: Author!
  authorId: BigInt!
  book: Book!
  bookId: BigInt!
  role: ArchitectRole!
}

type ArchitectsOnBooksAvgAggregate {
  authorId: Float
  bookId: Float
}

type ArchitectsOnBooksCountAggregate {
  _all: Int!
  authorId: Int!
  bookId: Int!
  role: Int!
}

input ArchitectsOnBooksListRelationFilter {
  every: ArchitectsOnBooksWhereInput
  none: ArchitectsOnBooksWhereInput
  some: ArchitectsOnBooksWhereInput
}

type ArchitectsOnBooksMaxAggregate {
  authorId: BigInt
  bookId: BigInt
  role: ArchitectRole
}

type ArchitectsOnBooksMinAggregate {
  authorId: BigInt
  bookId: BigInt
  role: ArchitectRole
}

input ArchitectsOnBooksOrderByRelationAggregateInput {
  _count: SortOrder
}

type ArchitectsOnBooksSumAggregate {
  authorId: BigInt
  bookId: BigInt
}

input ArchitectsOnBooksWhereInput {
  AND: [ArchitectsOnBooksWhereInput!]
  NOT: [ArchitectsOnBooksWhereInput!]
  OR: [ArchitectsOnBooksWhereInput!]
  author: AuthorRelationFilter
  authorId: BigIntFilter
  book: BookRelationFilter
  bookId: BigIntFilter
  role: EnumArchitectRoleFilter
}

"""
This model will keep track of authors that will be made available to the users
"""
type Author {
  _count: AuthorCount!
  bio: String
  books: [ArchitectsOnBooks!]
  createdAt: DateTime!
  id: BigInt!
  name: String!
  openLibraryKey: String!
  updatedAt: DateTime!
}

type AuthorAvgAggregate {
  id: Float
}

type AuthorCount {
  books: Int!
}

type AuthorCountAggregate {
  _all: Int!
  bio: Int!
  createdAt: Int!
  id: Int!
  name: Int!
  openLibraryKey: Int!
  updatedAt: Int!
}

type AuthorMaxAggregate {
  bio: String
  createdAt: DateTime
  id: BigInt
  name: String
  openLibraryKey: String
  updatedAt: DateTime
}

type AuthorMinAggregate {
  bio: String
  createdAt: DateTime
  id: BigInt
  name: String
  openLibraryKey: String
  updatedAt: DateTime
}

input AuthorRelationFilter {
  is: AuthorWhereInput
  isNot: AuthorWhereInput
}

type AuthorSumAggregate {
  id: BigInt
}

input AuthorWhereInput {
  AND: [AuthorWhereInput!]
  NOT: [AuthorWhereInput!]
  OR: [AuthorWhereInput!]
  bio: StringNullableFilter
  books: ArchitectsOnBooksListRelationFilter
  createdAt: DateTimeFilter
  id: BigIntFilter
  name: StringFilter
  openLibraryKey: StringFilter
  updatedAt: DateTimeFilter
}

"""
The `BigInt` scalar type represents non-fractional signed whole numeric values.
"""
scalar BigInt

input BigIntFilter {
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedBigIntFilter
  notIn: [String!]
}

"""
This model will keep track of books that will be made available to the users
"""
type Book {
  BookProgressLog: [BookProgressLog!]
  _count: BookCount!
  architects: [ArchitectsOnBooks!]
  createdAt: DateTime!
  description: String
  id: BigInt!
  isbn: String!
  shelves: [Shelf!]
  title: String!
  updatedAt: DateTime!
}

type BookAvgAggregate {
  id: Float
}

type BookCount {
  BookProgressLog: Int!
  architects: Int!
  shelves: Int!
}

type BookCountAggregate {
  _all: Int!
  createdAt: Int!
  description: Int!
  id: Int!
  isbn: Int!
  title: Int!
  updatedAt: Int!
}

input BookListRelationFilter {
  every: BookWhereInput
  none: BookWhereInput
  some: BookWhereInput
}

type BookMaxAggregate {
  createdAt: DateTime
  description: String
  id: BigInt
  isbn: String
  title: String
  updatedAt: DateTime
}

type BookMinAggregate {
  createdAt: DateTime
  description: String
  id: BigInt
  isbn: String
  title: String
  updatedAt: DateTime
}

input BookOrderByRelationAggregateInput {
  _count: SortOrder
}

input BookOrderByWithRelationInput {
  BookProgressLog: BookProgressLogOrderByRelationAggregateInput
  architects: ArchitectsOnBooksOrderByRelationAggregateInput
  createdAt: SortOrder
  description: SortOrder
  id: SortOrder
  isbn: SortOrder
  shelves: ShelfOrderByRelationAggregateInput
  title: SortOrder
  updatedAt: SortOrder
}

"""Model to track a user's reading progress with a particular book"""
type BookProgressLog {
  book: Book!
  bookId: BigInt!
  id: BigInt!
  numPages: Int!

  """Face value, so if a book is 82% complete, this value will be `82.00`"""
  percentage: Decimal!
  startedOn: DateTime!
  updatedOn: DateTime!
  user: User!
  userId: String!
}

type BookProgressLogAvgAggregate {
  bookId: Float
  id: Float
  numPages: Float
  percentage: Decimal
}

type BookProgressLogCountAggregate {
  _all: Int!
  bookId: Int!
  id: Int!
  numPages: Int!
  percentage: Int!
  startedOn: Int!
  updatedOn: Int!
  userId: Int!
}

input BookProgressLogListRelationFilter {
  every: BookProgressLogWhereInput
  none: BookProgressLogWhereInput
  some: BookProgressLogWhereInput
}

type BookProgressLogMaxAggregate {
  bookId: BigInt
  id: BigInt
  numPages: Int
  percentage: Decimal
  startedOn: DateTime
  updatedOn: DateTime
  userId: String
}

type BookProgressLogMinAggregate {
  bookId: BigInt
  id: BigInt
  numPages: Int
  percentage: Decimal
  startedOn: DateTime
  updatedOn: DateTime
  userId: String
}

input BookProgressLogOrderByRelationAggregateInput {
  _count: SortOrder
}

type BookProgressLogSumAggregate {
  bookId: BigInt
  id: BigInt
  numPages: Int
  percentage: Decimal
}

input BookProgressLogWhereInput {
  AND: [BookProgressLogWhereInput!]
  NOT: [BookProgressLogWhereInput!]
  OR: [BookProgressLogWhereInput!]
  book: BookRelationFilter
  bookId: BigIntFilter
  id: BigIntFilter
  numPages: IntFilter
  percentage: DecimalFilter
  startedOn: DateTimeFilter
  updatedOn: DateTimeFilter
  user: UserRelationFilter
  userId: StringFilter
}

input BookRelationFilter {
  is: BookWhereInput
  isNot: BookWhereInput
}

enum BookScalarFieldEnum {
  createdAt
  description
  id
  isbn
  title
  updatedAt
}

type BookSumAggregate {
  id: BigInt
}

input BookWhereInput {
  AND: [BookWhereInput!]
  BookProgressLog: BookProgressLogListRelationFilter
  NOT: [BookWhereInput!]
  OR: [BookWhereInput!]
  architects: ArchitectsOnBooksListRelationFilter
  createdAt: DateTimeFilter
  description: StringNullableFilter
  id: BigIntFilter
  isbn: StringFilter
  shelves: ShelfListRelationFilter
  title: StringFilter
  updatedAt: DateTimeFilter
}

input BookWhereUniqueInput {
  id: String
}

input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

"""Type returned for the error when a new user is created."""
type CreateUserError {
  """General errors relating to the registration attempt"""
  message: String
}

"""Result type returned as the result when new user is created."""
union CreateUserResultUnion = CreateUserError | UserDto

input CreateUserShelfInput {
  description: String
  isPublic: Boolean
  name: String!
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

"""An arbitrary-precision Decimal type"""
scalar Decimal

input DecimalFilter {
  equals: Decimal
  gt: Decimal
  gte: Decimal
  in: [Decimal!]
  lt: Decimal
  lte: Decimal
  not: NestedDecimalFilter
  notIn: [Decimal!]
}

"""
A field whose value conforms to the standard internet email address format as specified in RFC822: https://www.w3.org/Protocols/rfc822/.
"""
scalar EmailAddress @specifiedBy(url: "https://www.w3.org/Protocols/rfc822/")

input EnumArchitectRoleFilter {
  equals: ArchitectRole
  in: [ArchitectRole!]
  not: NestedEnumArchitectRoleFilter
  notIn: [ArchitectRole!]
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

"""The type returned for the errors when login is unsuccessful"""
type LoginError implements APIError {
  """The error message corresponding to this login attempt"""
  message: String!
}

"""The type returned on successful login"""
type LoginResult {
  """Wether the login attempt was successful"""
  status: Boolean!

  """The user this login result is associated with"""
  user: UserDto!
}

"""Result type returned as the result when someone tries to login"""
union LoginResultUnion = LoginError | LoginResult

type Mutation {
  """Mutation to create a new user with a given authentication token."""
  createUser(issuer: String!): CreateUserResultUnion!

  """Create a shelf for the current user."""
  createUserShelf(input: CreateUserShelfInput!): Shelf!

  """Login using an authentication token."""
  loginUser(issuer: String!): LoginResultUnion!
}

input NestedBigIntFilter {
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedBigIntFilter
  notIn: [String!]
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedDecimalFilter {
  equals: Decimal
  gt: Decimal
  gte: Decimal
  in: [Decimal!]
  lt: Decimal
  lte: Decimal
  not: NestedDecimalFilter
  notIn: [Decimal!]
}

input NestedEnumArchitectRoleFilter {
  equals: ArchitectRole
  in: [ArchitectRole!]
  not: NestedEnumArchitectRoleFilter
  notIn: [ArchitectRole!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

type Query {
  """Check whether a user with the given issuer exists in the database."""
  checkUserByIssuer(issuer: String!): Boolean!

  """Get a filtered list of all books in the service."""
  filterBooks(cursor: BookWhereUniqueInput, distinct: [BookScalarFieldEnum!], orderBy: [BookOrderByWithRelationInput!], skip: Int, take: Int, where: BookWhereInput): [Book!]!

  """Get a list of all shelves created by this user."""
  filterUserShelves(cursor: ShelfWhereUniqueInput, distinct: [ShelfScalarFieldEnum!], orderBy: [ShelfOrderByWithRelationInput!], skip: Int, take: Int, where: ShelfWhereInput): [Shelf!]!

  """Get status of the service."""
  getStatus: Boolean!

  """Get list of book progresses that are related to the user."""
  userBookProgressLogs(take: Int): [BookProgressLog!]!

  """Get a small list of authors that are related to the user."""
  userRelatedAuthors: [Author!]!

  """Get a small list of books that are related to the user."""
  userRelatedBooks: [Book!]!
}

enum QueryMode {
  default
  insensitive
}

"""A shelf is created by users to collect a number of books together"""
type Shelf {
  _count: ShelfCount!
  books: [Book!]
  createdAt: DateTime!
  description: String
  id: ID!
  isPublic: Boolean!
  name: String!
  updatedAt: DateTime!
  user: User!
  userId: String!
}

type ShelfCount {
  books: Int!
}

type ShelfCountAggregate {
  _all: Int!
  createdAt: Int!
  description: Int!
  id: Int!
  isPublic: Int!
  name: Int!
  updatedAt: Int!
  userId: Int!
}

input ShelfListRelationFilter {
  every: ShelfWhereInput
  none: ShelfWhereInput
  some: ShelfWhereInput
}

type ShelfMaxAggregate {
  createdAt: DateTime
  description: String
  id: String
  isPublic: Boolean
  name: String
  updatedAt: DateTime
  userId: String
}

type ShelfMinAggregate {
  createdAt: DateTime
  description: String
  id: String
  isPublic: Boolean
  name: String
  updatedAt: DateTime
  userId: String
}

input ShelfOrderByRelationAggregateInput {
  _count: SortOrder
}

input ShelfOrderByWithRelationInput {
  books: BookOrderByRelationAggregateInput
  createdAt: SortOrder
  description: SortOrder
  id: SortOrder
  isPublic: SortOrder
  name: SortOrder
  updatedAt: SortOrder
  user: UserOrderByWithRelationInput
  userId: SortOrder
}

enum ShelfScalarFieldEnum {
  createdAt
  description
  id
  isPublic
  name
  updatedAt
  userId
}

input ShelfWhereInput {
  AND: [ShelfWhereInput!]
  NOT: [ShelfWhereInput!]
  OR: [ShelfWhereInput!]
  books: BookListRelationFilter
  createdAt: DateTimeFilter
  description: StringNullableFilter
  id: StringFilter
  isPublic: BoolFilter
  name: StringFilter
  updatedAt: DateTimeFilter
  user: UserRelationFilter
  userId: StringFilter
}

input ShelfWhereUniqueInput {
  id: String
}

enum SortOrder {
  asc
  desc
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

"""
A field whose value is a generic Universally Unique Identifier: https://en.wikipedia.org/wiki/Universally_unique_identifier.
"""
scalar UUID

"""This model will represent a user of the service."""
type User {
  BookProgressLog: [BookProgressLog!]
  _count: UserCount!
  createdAt: DateTime!
  id: ID!
  issuer: String!
  profile: UserProfile
  shelves: [Shelf!]
}

type UserCount {
  BookProgressLog: Int!
  shelves: Int!
}

type UserCountAggregate {
  _all: Int!
  createdAt: Int!
  id: Int!
  issuer: Int!
}

"""Critical details about a user of the service"""
type UserDto {
  id: ID!
}

type UserMaxAggregate {
  createdAt: DateTime
  id: String
  issuer: String
}

type UserMinAggregate {
  createdAt: DateTime
  id: String
  issuer: String
}

input UserOrderByWithRelationInput {
  BookProgressLog: BookProgressLogOrderByRelationAggregateInput
  createdAt: SortOrder
  id: SortOrder
  issuer: SortOrder
  profile: UserProfileOrderByWithRelationInput
  shelves: ShelfOrderByRelationAggregateInput
}

"""This model will track profile information about the user"""
type UserProfile {
  age: Int
  bio: String
  countryId: Int
  email: EmailAddress!
  id: UUID!
  updatedAt: DateTime!
  user: User!
  userId: String!
  username: String!
}

type UserProfileAvgAggregate {
  age: Float
  countryId: Float
}

type UserProfileCountAggregate {
  _all: Int!
  age: Int!
  bio: Int!
  countryId: Int!
  email: Int!
  id: Int!
  updatedAt: Int!
  userId: Int!
  username: Int!
}

type UserProfileMaxAggregate {
  age: Int
  bio: String
  countryId: Int
  email: EmailAddress
  id: UUID
  updatedAt: DateTime
  userId: String
  username: String
}

type UserProfileMinAggregate {
  age: Int
  bio: String
  countryId: Int
  email: EmailAddress
  id: UUID
  updatedAt: DateTime
  userId: String
  username: String
}

input UserProfileOrderByWithRelationInput {
  age: SortOrder
  bio: SortOrder
  countryId: SortOrder
  email: SortOrder
  id: SortOrder
  updatedAt: SortOrder
  user: UserOrderByWithRelationInput
  userId: SortOrder
  username: SortOrder
}

input UserProfileRelationFilter {
  is: UserProfileWhereInput
  isNot: UserProfileWhereInput
}

type UserProfileSumAggregate {
  age: Int
  countryId: Int
}

input UserProfileWhereInput {
  AND: [UserProfileWhereInput!]
  NOT: [UserProfileWhereInput!]
  OR: [UserProfileWhereInput!]
  age: IntNullableFilter
  bio: StringNullableFilter
  countryId: IntNullableFilter
  email: StringFilter
  id: StringFilter
  updatedAt: DateTimeFilter
  user: UserRelationFilter
  userId: StringFilter
  username: StringFilter
}

input UserRelationFilter {
  is: UserWhereInput
  isNot: UserWhereInput
}

input UserWhereInput {
  AND: [UserWhereInput!]
  BookProgressLog: BookProgressLogListRelationFilter
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  createdAt: DateTimeFilter
  id: StringFilter
  issuer: StringFilter
  profile: UserProfileRelationFilter
  shelves: ShelfListRelationFilter
}
